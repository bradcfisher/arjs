import { reverse } from "dns";

/*
TODO: Register a Typescript bug for the following?

enum E {
	zero = 0,
	one = 1,
	two = 2
}

class A {
	private _foo: E;

	constructor(foo: E) {
		this._foo = foo;
	}

	baz() {
		this._foo = E.zero;
	}

	bar() {
		if (this._foo != E.zero) {
			this.baz();

			// The TypeScript compiler raises ts(2367) here, indicating that _foo cannot possibly be E.zero
			// At first glance, that may seem correct, since the if test above asserts that to be true.
			// However, once execution reaches this point, that assertion no longer holds, since _foo is
			// updated to E.zero by the call to baz.
			// It seems the compiler is not properly determining that baz can modify the property,
			// and thus is enforcing an incorrect type inference.
			if (this._foo == E.zero) {
				// Do something
			}
		}
	}
}
// */

/**
 * Serializes the specified value using a custom JSON format that supports
 * object references (circular or otherwise), custom serialization callbacks
 * and concrete class reconstitution.
 *
 * @param value the value to serialize.
 */
export function serialize(value: any): string {
	return (new Serializer()).serialize(value);
}

export function deserialize(data: string): any {
	return (new Deserializer()).deserialize(data);
}

export type SerializedData = {
	//readonly "$type": [string,number|string]|string|number;
	readonly [key:string]: any
};

/**
 * Signature for a factory function to invoke to create new instances of a class
 * during deserialization.
 *
 * Since this function is responsible for creating the object, it is not possible to
 * deserialize child properties with a circular reference back to the object being
 * created.  Attempts to do so will result in an exception.
 *
 * @param entry the ClassEntry for the class.
 * @param data the serialized data associated with the object.  May be used for
 * 		extracting constructor arguments, etc., but will not support circular
 * 		references back to the object being constructed.
 * @param deserializer the deserializer to use to deserialize any necessary
 * 		values from the `data`.
 */
type FactoryCallback = (entry: ClassEntry, data: SerializedData, deserializer: Deserializer) => Object;

/**
 * Signature for custom class serialization methods.
 *
 * @param obj the object being serialized.
 * @param serializer the Serializer instance to use for serializing data.
 */
type SerializeCallback = (obj: Object, serializer: Serializer) => void;

/**
 * Signature for custom class deserialization methods.
 *
 * @param obj the object being deserialized.
 * @param data the data associated with the object as generated by the class'
 * 				serialization callback.
 * @param deserializer the Deserializer instance to use for deserializing data.
 */
type DeserializeCallback = (obj: Object, data: SerializedData, deserializer: Deserializer) => void;

/**
 * Class entry properties for the ClassRegistry.
 */
export interface ClassEntry {
	/**
	 * Name of the class this entry is for.
	 */
	readonly name: string;
	/**
	 * Class' constructor function.
	 *
	 * This function will be used to identify members of the class for serialization,
	 * as well as to construct new instances during deserialization if a factory function
	 * isn't defined.
	 */
	readonly constructorFunction: Function;

	/**
	 * Factory method to invoke to create new instances of this class during deserialization.
	 *
	 * If not defined, instances will be created using the constructor function.
	 *
	 * Since this function is responsible for creating the object, it is not possible to
	 * deserialize child properties with a circular reference back to the object being
	 * created.  Attempts to do so will result in an exception.
	 */
	readonly factory?: FactoryCallback;

	/**
	 * Serialization callback to invoke to serialize instances of this class.
	 */
	readonly serializer?: SerializeCallback;

	/**
	 * Deserialization callback to invoke to deserialize instances of this class.
	 * This function is invoked _after_ the instance is created, so circular references
	 * are supported.
	 */
	readonly deserializer?: DeserializeCallback;
}

/**
 * Registry of class names and constructor functions to use during serialization
 * and deserialization.
 *
 * When serializing, entries are retrieved based on an object's constructor.  Only objects
 * that match a registered constructor can be serialized.
 *
 * When deserializing, entries are retrieved based on the target class name.  Only classes
 * that have been registered can be successfully deserialized.
 */
export class ClassRegistry {
	private static readonly _registryByName: Map<string, ClassEntry> = new Map();
	private static readonly _registryByConstructor: Map<Function, ClassEntry> = new Map();

	/**
	 * Registers a class name/conssrtuctor and associated callbacks.
	 *
	 * @param name the class name.
	 * @param constructorFunction the class constructor function to associate with the name.
	 * @param serializer	serialization function to invoke for objects with the
	 * 			specified constructor.  If this argument is omitted, the `constructorFunction`
	 * 			will be examined for an associated `serialize` method instead.  If neither is
	 * 			set, the default "bare" object serialization will be used.
	 * @param deserializer	deserialization function to invoke when objects with the
	 * 			specified class name are encountered.  If this argument is omitted, the
	 * 			`constructorFunction` will be examined for an associated `deserialize`
	 * 			method instead.  If neither is set, the default "bare" object deserialization
	 * 			will be used.
	 * @param factory		factory function to use for constructing new instances instead
	 * 			of the `constructorFunction`.  If this argument is omitted, the
	 * 			`constructorFunction` will be examined for an associated `factory`
	 * 			method instead.  If neither is set, new instances of this class will be
	 * 			created by invoking the `constructorFunction` via the `new` operator.
	 *
	 * @throws Error if the specified name or constructor function are already registered.
	 *
	 * @see [[ClassEntry]]
	 */
	static registerClass<T>(
		name: string,
		constructorFunction: Function,
		serializer?: (obj: T, serializer: Serializer) => void,
		deserializer?: (obj: T, data: SerializedData, deserializer: Deserializer) => void,
		factory?: (entry: ClassEntry, data: SerializedData, deserializer: Deserializer) => T
	): void {
		if (this._registryByName.has(name))
			throw new Error("Class name '" + name + "' already registered");

		let prevName: ClassEntry|undefined = this._registryByConstructor.get(constructorFunction);
		if (prevName != null)
			throw new Error("Class constructor already registered under name '" + prevName.name + "'");

		if (serializer == null)
			serializer = (<any>constructorFunction).serialize;

		if (deserializer == null)
			deserializer = (<any>constructorFunction).deserialize;

		if (factory == null)
			factory = (<any>constructorFunction).factory

		let entry: ClassEntry = {
			name: name,
			constructorFunction: constructorFunction,
			serializer: serializer as SerializeCallback,
			deserializer: deserializer as DeserializeCallback,
			factory: factory as FactoryCallback
		};

		this._registryByName.set(name, entry);
		this._registryByConstructor.set(constructorFunction, entry);
	}

	/**
	 * Retrieves a registry entry by class name or constructor.
	 *
	 * @param nameOrConstructor The class name or constructor function to retrieve the entry for.
	 *
	 * @return The `ClassEntry` matching the name/constructor, or undefined if not found.
	 */
	static getClassEntry(nameOrConstructor: string|Function): ClassEntry|undefined {
		if (nameOrConstructor instanceof Function) {
			return this._registryByConstructor.get(nameOrConstructor);
		} else
			return this._registryByName.get(nameOrConstructor);
	}
}

/**
 * Class for serializing values to a custom JSON format that supports
 * object references (circular or otherwise), custom serialization callbacks
 * and concrete class reconstitution.
 *
 * The serialized data will be valid JSON, but some values will be serialized using
 * a custom format as follows:
 *
 * - Symbols for which Symbol.keyFor() returns a value:
 *   `{"$type":["Symbol", "some symbol key"]}`
 *
 * - Objects that have not been serialized earlier in the output which were created using
 *   the Object constructor or are instances of a registered custom class:
 *   `{"$type": ["SomeClassName", 1234], ...data props}`
 *   Where the reference number (1234 in the above example) will be unique for each object
 *   in the output.  The associated data properties will be encoded based on the serializer
 *   function registered for the class.
 *
 * - Objects which have been serialized earlier in the output:
 *   `{"$type": 1234}`
 *   Where the reference number (1234 in the above example) will be unique for each object
 *   in the output.
 *
 * - undefined will be serialized as:
 *   `{"$type":"undefined"}`
 *
 * @see [[Deserializer]]
 */
export class Serializer {

	// TODO: Support serialization to a stream or file?

	/**
	 * Name of the property that holds the object type and reference id.
	 */
	private readonly _typeKeyName: string;

	private readonly _typeKeyNameJson: string;

	/**
	 * Property path from the root to the current value.
	 * Updated for each object property or array element
	 */
	private readonly _path: string[] = [];

	/**
	 * Flag indicating whether additional data may be serialized or not.
	 */
	private _closed: boolean = false;

	/**
	 * The object currently being serialized, or undefined if not serializing an object.
	 * Used for determining if an object attempts to serialize itself, and whether calls
	 * to writeProp are valid.
	 */
	private _currentObject: Object|undefined;

	/**
	 * Serialized fragments generated up to the current point in the process.
	 */
	private readonly _buffer: string[] = [];

	/**
	 * The number of objects serialized so far.
	 */
	private _referenceCount: number = 0;

	/**
	 * Map of {object -> reference id} for all objects serialized so far.
	 * Used to support circular references and ensure instance identities are preserved
	 * in the serialized data by writing a reference instead of infinitely recursing or
	 * re-serializing when an object is encountered multiple times.
	 */
	private readonly _references: Map<Object, number> = new Map();

	/**
	 * Constructs a new serializer which uses the specified type key name when serializing
	 * objects.
	 *
	 * @param typeKeyName the object property name to use for storing an object's type and
	 * 		reference information.  Defaults to '$type'.
	 */
	constructor(typeKeyName: string = "$type") {
		this._typeKeyName = typeKeyName;
		this._typeKeyNameJson = JSON.stringify(typeKeyName);
	}

	/**
	 * The object property name to use for storing an object's type and reference information.
	 */
	get typeKeyName(): string {
		return this._typeKeyName;
	}

	/**
	 * Serialize the specified value and return the result.
	 *
	 * @param value the value to serialize.
	 *
	 * @return the serialized string.
	 */
	serialize(value: any): string {
		this.write(value);
		return this.getString();
	}

	/**
	 * Retrieve the serialized string and clear the internal buffer.
	 *
	 * This would usually be called at the end of an incremental serialization.
	 *
	 * @return the serialized string up to the current point in the process.
	 * @throws Error if the serializer's closed flag is not set.
	 */
	getString(): string {
		this.assertClosed();
		return this._buffer.join("");
	}

	/**
	 * Appends the specified strings to the end of the serialization buffer.
	 * @param pieces the strings to append.
	 */
	private append(...pieces: string[]): void {
		this._buffer.push(...pieces);
	}

	/**
	 * Ensures that the closed flag is set, and throws an Error if not.
	 */
	private assertClosed(): void {
		if (!this._closed)
			throw new Error("Serialization incomplete at '" + this._path.join(".") + "'");
	}

	/**
	 * Ensures that writing new values is possible.
	 *
	 * Performs the following checks:
	 * - Checks that the closed flag is NOT set.
	 * - Requires there is no current object being written.
	 *
	 * @throws Error if any of the above checks fail.
	 */
	private assertCanWrite(): void {
		if (this._closed)
			throw new Error("Current state doesn't permit writing value at '" + this._path.join(".") + "'");

		if (this._currentObject != null)
			throw new Error("Cannot write value without property name, call writeProp instead");
	}

	/**
	 * Sets the closed flag if the current nesting level is 0.
	 */
	private closeIfTopLevel(): void {
		if (this._path.length == 0)
			this._closed = true;
	}

	/**
	 * Appends all object properties from the specified object to the serialized data
	 * for the current object.
	 *
	 * May only be called from within a serialization function for a registered class.
	 *
	 * @param props an object containing the properties to write.
	 *
	 * @throws Error if not currently executing a serialization function, or if
	 *		serialization fails.
	 */
	writeProp(props: Object): void;

	/**
	 * Appends an object property to the serialized data for the current object.
	 *
	 * May only be called from within a serialization function for a registered class.
	 *
	 * @param name the name of the property to write.
	 * @param value the value for the property.
	 *
	 * @throws Error if not currently executing a serialization function, or if
	 *		serialization fails.
	 */
	writeProp(nameOrProps: string, value: any): void;

	writeProp(nameOrProps: string|Object, value?: any): void {
		if (this._currentObject == null) {
			throw new Error("writeProp may only be invoked from inside a custom serialization callback");
		}

		let prevCurrent: Object|undefined = this._currentObject;
		this._currentObject = undefined;

		let n: number = this._path.length;

		let write = (name: string, value: any): void => {
			this._path[n] = name;
			this.append(",");
			this.append(JSON.stringify(name), ':');
			this.write(value);
		}

		if (typeof nameOrProps === "string") {
			write(nameOrProps, value);
		} else {
			let obj: any = nameOrProps;
			for (let name in obj) if (obj.hasOwnProperty(name))
				write(name, obj[name]);
		}

		this._path.length = n;

		this._currentObject = prevCurrent;
	}

	/**
	 * Writes the specified object in a "bare" format.
	 *
	 * @param obj the object being serialized.
	 * @param serializer the Serializer instance.
	 */
	private defaultSerializerCallback(obj: any, serializer: Serializer): void {
		for (let name in obj) if (obj.hasOwnProperty(name)) {
			serializer.writeProp(name, obj[name]);
		}
	}

	/**
	 * Serializes the specified object.
	 *
	 * @param obj the object to serialize.
	 *
	 * @throws Error if the serializer's closed flag is set, the class name could not
	 * 		be determined (possibly unregistered constructor), the class' serialize
	 *		function did not write anything, or serialization of a child property failed.
	 */
	writeObject(obj: Object): void {
		if ((obj == null) || (obj instanceof String) || (obj instanceof Boolean) || (obj instanceof Number)) {
			this.writePrimitive(obj.valueOf());
			return;
		}

		this.assertCanWrite();

		let refId: number|undefined = this._references.get(obj);
		if (refId != null) {
			this.append('{', this._typeKeyNameJson, ':', String(refId), '}');
		} else {
			refId = this._referenceCount++;
			this._references.set(obj, refId);

			let classEntry: ClassEntry|undefined = ClassRegistry.getClassEntry(obj.constructor);
			if (classEntry == null)
				throw new Error("Unable to determine object class name at '" + this._path.join(".") + "'");

			this.append(
				'{', this._typeKeyNameJson, ':[', JSON.stringify(classEntry.name), ',', JSON.stringify(refId), ']'
			);

			let serializer: SerializeCallback|undefined = classEntry.serializer;
			if (serializer == null)
				serializer = this.defaultSerializerCallback;

			let prevCurrent: Object|undefined = this._currentObject;
			this._currentObject = obj;

			serializer(obj, this);

			this._currentObject = prevCurrent;

			this.append("}");
		}

		this.closeIfTopLevel();
	}

	/**
	 * Serializes the specified array.
	 *
	 * @param value the array to serialize.
	 *
	 * @throws Error if the serializer's closed flag is set, or serialization of
	 * 		an item in the array failed.
	 */
	writeArray(value: ReadonlyArray<any>) {
		this.assertCanWrite();

		this.append("[");

		let n: number = this._path.length;
		let index: number = 0;
		for (let item of value) {
			if (index > 0)
				this.append(",");

			this._path[n] = String(index++);
			this.write(item);
		}
		this._path.length = n;

		this.append("]");

		this.closeIfTopLevel();
	}

	/**
	 * Serializes the specified primitive (string,number,boolean,null,undefined) value.
	 * @param value the primitive value to serialize.
	 */
	writePrimitive(value: String|number|boolean|null|undefined): void {
		this.assertCanWrite();

		if (value === undefined) {
			// Special value written to preserve undefined
			this.append('{"$type":"undefined"}');
		} else {
			this.append(JSON.stringify(value));
		}

		this.closeIfTopLevel();
	}

	/**
	 * Serializes the specified global symbol.
	 *
	 * @param symbol the symbol to serialize.
	 *
	 * @throws Error if the symbol key could not be retrieved (e.g. not a global symbol
	 *			created with Symbol.for).
	 */
	writeSymbol(symbol: symbol): void {
		this.assertCanWrite();

		let key: string|undefined = Symbol.keyFor(symbol);
		if (key == null)
			throw new Error("Unable to determine key for symbol at '" + this._path.join(".") + "'");

		this.append('{', this._typeKeyNameJson, ':["Symbol",', JSON.stringify(key), ']}');

		this.closeIfTopLevel();
	}

	/**
	 * Serializes the specified value.
	 *
	 * @param	value the value to serialize.
	 *
	 * @throws Error if the value could not be serialized successfully.
	 */
	write(value: any): void {
		let t = typeof value;
		switch (t) {
		case "object":
			if (Array.isArray(value))
				this.writeArray(value);
			else
				this.writeObject(value);
			break;

		case "function": // Callbacks created by Parse.action/Parse.listener/etc can be serialized
			this.writeObject(value);
			break;

		case "string":
		case "number":
		case "boolean":
		case "undefined":
			this.writePrimitive(value);
			break;

		case "symbol":
			this.writeSymbol(value);
			break;

		default:
			throw new Error("Cannot serialize " + t + " value at '" + this._path.join(".") + "'");
		}
	}
}

/**
 * Deserializes data serialized by the Serializer class.
 * @see [[Serializer]]
 */
export class Deserializer {
	/**
	 * Name of the property that holds the object type and reference id.
	 */
	private readonly _typeKeyName: string;

	/**
	 * Property path from root to the current value
	 */
	private readonly _path: string[] = [];

	/**
	 * Map of {reference id -> object} for all objects deserialized so far.
	 * Used for resolving references encountered in the serialized data to their
	 * respective object instances.
	 */
	private readonly _references: Map<number, Object> = new Map();

	/**
	 * The object currently being deserialized, or undefined if not deserializing an object.
	 * Used for determining if a custom deserialize function calls readObject with the
	 * data object passed to deserialize, which should invoke the default deserialization.
	 */
	private _currentObject: Object|undefined;

	constructor(typeKeyName: string = '$type') {
		this._typeKeyName = typeKeyName;
	}

	get typeKeyName(): string {
		return this._typeKeyName;
	}

	/**
	 * Deserializes a string into the object structure it represents.
	 * @param data the string to deserialize.
	 */
	deserialize(data: string): any {
		return this.read(JSON.parse(data));
	}

	private assertCanRead(): void {
		if (this._currentObject != null)
			throw new Error("Cannot read value without property name, call readProp instead");
	}

	/**
	 * Recursively deserializes the items in the specified array.
	 * @param value the array to process.
	 * @return a new array containing the deserialized values.
	 */
	readArray(value: ReadonlyArray<any>): any[] {
		this.assertCanRead();

		let rv: any[] = [];
		let n: number = this._path.length;
		for (let i = 0; i < value.length; ++i) {
			this._path[n] = String(i);
			rv[i] = this.read(value[i]);
		}
		this._path.length = n;
		return rv;
	}

	/**
	 * Reads all properties from a source object and returns a new object containing the
	 * deserialized property values.
	 *
	 * @param sourceObj the serialized object to read the properties from.
	 *
	 * @return a new object containing the deserialized property data.
	 */
	readProp(sourceObj: SerializedData): Object;

	/**
	 * Reads a property from a source object and returns the deserialized value.
	 *
	 * @param sourceObj the serialized object to read the property from.
	 * @param name the name of the property to read.
	 *
	 * @return the deserialized property value.
	 */
	readProp(sourceObj: SerializedData, name: string): any;

	/**
	 * Reads all properties from a source object and writes the deserialized property values
	 * into a provided destination object.
	 *
	 * @param sourceObj the serialized object to read the properties from.
	 * @param destObj the destination object to write the deserialized property values to.
	 *
	 * @return the destination object.
	 */
	readProp(sourceObj: SerializedData, destObj: Object): Object;

	readProp(sourceObj: SerializedData, nameOrDest?: string|Object): any {
		if (this._currentObject == null) {
			throw new Error("readProp may only be invoked from inside a custom deserialization callback");
		}

		let prevCurrent: Object|undefined = this._currentObject;
		this._currentObject = undefined;

		let n: number = this._path.length;
		let read = (name: string): any => {
			this._path[n] = name;
			return this.read(sourceObj[name]);
		}

		let rv: any;
		if (typeof nameOrDest === "string") {
			// Read a single property
			rv = read(nameOrDest);
		} else {
			if (nameOrDest == null)
				nameOrDest = {};

			// Read object
			rv = nameOrDest;
			for (let name in sourceObj) {
				if (sourceObj.hasOwnProperty(name) && (name != this._typeKeyName)) {
					rv[name] = read(name);
				}
			}
		}

		this._path.length = n;

		this._currentObject = prevCurrent;
		return rv;
	}

	/**
	 * Default Object deserialize callback.
	 *
	 * Recursively deseralizes each property of the data object and assigns the result
	 * to the corresponding property of the target object.
	 *
	 * @param destObj the target object to apply deserialized values to.
	 * @param data the serialized object data.
	 * @param deserializer the deserializer to use for deserializing values.
	 */
	private defaultDeserializerCallback(destObj: Object, data: SerializedData, deserializer: Deserializer): void {
		deserializer.readProp(data, destObj);
	}

	/**
	 * Recursively deserializes the specified object.
	 * @param obj the serialized object data to deserialize.
	 * @return the deserialized object.
	 */
	readObject(obj: Object): Object|undefined {
		this.assertCanRead();

		if ((obj == null) || (obj instanceof String) || (obj instanceof Boolean) || (obj instanceof Number)) {
			return obj;
		}

		let data: SerializedData = <any> obj;
		let $type: [string,number|string]|string|number|undefined = data[this._typeKeyName];
		if ($type != null) {
			if (typeof $type === "string") {
				if ($type == "undefined")
					return undefined;

				throw new Error("Invalid " + this._typeKeyName + " property value: "+ $type + " at " + this._path.join(".") + "'");
			}

			if (typeof $type == "number") {
				let rv: Object|undefined = this._references.get($type);
				if (rv != null)
					return rv;

				throw new Error("Invalid object reference #" + $type +" at " + this._path.join(".") + "'");
			}

			if (typeof $type[1] === "string") {
				return Symbol.for($type[1]);
			}

			let className: string = $type[0];
			let classEntry: ClassEntry|undefined = ClassRegistry.getClassEntry(className);
			if (classEntry == null)
				throw new Error("No registry entry for class '" + className + "' at " + this._path.join(".") + "'");

			let refId: number = $type[1];
			if (refId == null)
				throw new Error("Missing object reference id at " + this._path.join(".") + "'");

			let prevCurrent: Object|undefined = this._currentObject;
			this._currentObject = data;

			// Create new instance
			let rv: Object;
			if (classEntry.factory)
				rv = classEntry.factory.call(this, classEntry, data, this);
			else
				rv = new (<any>classEntry.constructorFunction)();

			// Register instance
			this._references.set(refId, rv);

			// Deserialize object properties
			let deserializer: DeserializeCallback|undefined = classEntry.deserializer;
			if (deserializer == null)
				deserializer = this.defaultDeserializerCallback;

			deserializer.call(this, rv, data, this);

			this._currentObject = prevCurrent;

			return rv;
		}

		throw new Error("Unable to deserialize object: Does not have '" + this._typeKeyName + "' property.");
	}

	/**
	 * Recursively deserializes the specified value.
	 * @param value the value to deserialize.
	 * @return the deserialized value.
	 */
	read(value: any): any {
		let t = typeof value;
		switch (t) {
		case "object":
			if (Array.isArray(value))
				return this.readArray(value);
			else
				return this.readObject(value);

		case "string":
		case "number":
		case "boolean":
		case "undefined":
			this.assertCanRead();
			return value;

		default:
			throw new Error("Cannot deserialize " + t + " value at '" + this._path.join(".") + "'");
		}
	}

}

ClassRegistry.registerClass('Object', Object);

ClassRegistry.registerClass('Map', Map,
	(map: Map<any,any>, serializer: Serializer):void => {
		let rv: [any,any][] = [];

		for (let item of map.entries())
			rv.push(item);

		serializer.writeProp("entries", rv);
	},
	(map: Map<any,any>, data: SerializedData, deserializer: Deserializer): void => {
		for (let item of deserializer.readProp(data, "entries")) {
			map.set(
				deserializer.read(item[0]),
				deserializer.read(item[1])
			);
		}
	}
);

ClassRegistry.registerClass('Set', Set,
	(set: Set<any>, serializer: Serializer):void => {
		let rv: any[] = [];

		for (let item of set.values())
			rv.push(item);

		serializer.writeProp("entries", rv);
	},
	(set: Set<any>, data: SerializedData, deserializer: Deserializer): void => {
		for (let item of deserializer.readProp(data, "entries"))
			set.add(item);
	}
);
